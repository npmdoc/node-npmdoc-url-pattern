<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/snd/url-pattern"

    >url-pattern (v1.0.3)</a>
</h1>
<h4>easier than regex string matching patterns for urls and other strings. turn strings into data or data into strings.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.url-pattern">module url-pattern</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.url-pattern">
            function <span class="apidocSignatureSpan"></span>url-pattern
            <span class="apidocSignatureSpan">(arg1, arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.astNodeContainsSegmentsForProvidedParams">
            function <span class="apidocSignatureSpan">url-pattern.</span>astNodeContainsSegmentsForProvidedParams
            <span class="apidocSignatureSpan">(astNode, params, nextIndexes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.astNodeToNames">
            function <span class="apidocSignatureSpan">url-pattern.</span>astNodeToNames
            <span class="apidocSignatureSpan">(astNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.astNodeToRegexString">
            function <span class="apidocSignatureSpan">url-pattern.</span>astNodeToRegexString
            <span class="apidocSignatureSpan">(astNode, segmentValueCharset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.concatMap">
            function <span class="apidocSignatureSpan">url-pattern.</span>concatMap
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.escapeForRegex">
            function <span class="apidocSignatureSpan">url-pattern.</span>escapeForRegex
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.getParam">
            function <span class="apidocSignatureSpan">url-pattern.</span>getParam
            <span class="apidocSignatureSpan">(params, key, nextIndexes, sideEffects)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.keysAndValuesToObject">
            function <span class="apidocSignatureSpan">url-pattern.</span>keysAndValuesToObject
            <span class="apidocSignatureSpan">(keys, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.newParser">
            function <span class="apidocSignatureSpan">url-pattern.</span>newParser
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.regexGroupCount">
            function <span class="apidocSignatureSpan">url-pattern.</span>regexGroupCount
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.stringConcatMap">
            function <span class="apidocSignatureSpan">url-pattern.</span>stringConcatMap
            <span class="apidocSignatureSpan">(array, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.stringify">
            function <span class="apidocSignatureSpan">url-pattern.</span>stringify
            <span class="apidocSignatureSpan">(astNode, params, nextIndexes)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">url-pattern.</span>P</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">url-pattern.</span>defaultOptions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url-pattern.P">module url-pattern.P</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.Result">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>Result
            <span class="apidocSignatureSpan">(value, rest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.Tagged">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>Tagged
            <span class="apidocSignatureSpan">(tag, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.baseMany">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>baseMany
            <span class="apidocSignatureSpan">(parser, end, stringResult, atLeastOneResultRequired, input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.concatMany1Till">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>concatMany1Till
            <span class="apidocSignatureSpan">(parser, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.firstChoice">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>firstChoice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.lazy">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>lazy
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.many1">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>many1
            <span class="apidocSignatureSpan">(parser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.pick">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>pick
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.regex">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>regex
            <span class="apidocSignatureSpan">(regex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.sequence">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>sequence
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.string">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>string
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url-pattern.P.tag">
            function <span class="apidocSignatureSpan">url-pattern.P.</span>tag
            <span class="apidocSignatureSpan">(tag, parser)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url-pattern" id="apidoc.module.url-pattern">module url-pattern</a></h1>


    <h2>
        <a href="#apidoc.element.url-pattern.url-pattern" id="apidoc.element.url-pattern.url-pattern">
        function <span class="apidocSignatureSpan"></span>url-pattern
        <span class="apidocSignatureSpan">(arg1, arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">url-pattern = function (arg1, arg2) {
  var groupCount, options, parsed, parser, withoutWhitespace;
  if (arg1 instanceof UrlPattern) {
    this.isRegex = arg1.isRegex;
    this.regex = arg1.regex;
    this.ast = arg1.ast;
    this.names = arg1.names;
    return;
  }
  this.isRegex = arg1 instanceof RegExp;
  if (!((&#x27;string&#x27; === typeof arg1) || this.isRegex)) {
    throw new TypeError(&#x27;argument must be a regex or a string&#x27;);
  }
  if (this.isRegex) {
    this.regex = arg1;
    if (arg2 != null) {
      if (!Array.isArray(arg2)) {
        throw new Error(&#x27;if first argument is a regex the second argument may be an array of group names but you provided something
 else&#x27;);
      }
      groupCount = regexGroupCount(this.regex);
      if (arg2.length !== groupCount) {
        throw new Error(&#x22;regex contains &#x22; + groupCount + &#x22; groups but array of group names contains &#x22; + arg2.length);
      }
      this.names = arg2;
    }
    return;
  }
  if (arg1 === &#x27;&#x27;) {
    throw new Error(&#x27;argument must not be the empty string&#x27;);
  }
  withoutWhitespace = arg1.replace(/\s+/g, &#x27;&#x27;);
  if (withoutWhitespace !== arg1) {
    throw new Error(&#x27;argument must not contain whitespace&#x27;);
  }
  options = {
    escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,
    segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,
    segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,
    segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,
    optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar
,
    optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,
    wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar
  };
  parser = newParser(options);
  parsed = parser.pattern(arg1);
  if (parsed == null) {
    throw new Error(&#x22;couldn&#x27;t parse pattern&#x22;);
  }
  if (parsed.rest !== &#x27;&#x27;) {
    throw new Error(&#x22;could only partially parse pattern&#x22;);
  }
  this.ast = parsed.value;
  this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));
  this.names = astNodeToNames(this.ast);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.astNodeContainsSegmentsForProvidedParams" id="apidoc.element.url-pattern.astNodeContainsSegmentsForProvidedParams">
        function <span class="apidocSignatureSpan">url-pattern.</span>astNodeContainsSegmentsForProvidedParams
        <span class="apidocSignatureSpan">(astNode, params, nextIndexes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">astNodeContainsSegmentsForProvidedParams = function (astNode, params, nextIndexes) {
  var i, length;
  if (Array.isArray(astNode)) {
    i = -1;
    length = astNode.length;
    while (++i &#x3c; length) {
      if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {
        return true;
      }
    }
    return false;
  }
  switch (astNode.tag) {
    case &#x27;wildcard&#x27;:
      return getParam(params, &#x27;_&#x27;, nextIndexes, false) != null;
    case &#x27;named&#x27;:
      return getParam(params, astNode.value, nextIndexes, false) != null;
    case &#x27;static&#x27;:
      return false;
    case &#x27;optional&#x27;:
      return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.astNodeToNames" id="apidoc.element.url-pattern.astNodeToNames">
        function <span class="apidocSignatureSpan">url-pattern.</span>astNodeToNames
        <span class="apidocSignatureSpan">(astNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">astNodeToNames = function (astNode) {
  if (Array.isArray(astNode)) {
    return concatMap(astNode, astNodeToNames);
  }
  switch (astNode.tag) {
    case &#x27;wildcard&#x27;:
      return [&#x27;_&#x27;];
    case &#x27;named&#x27;:
      return [astNode.value];
    case &#x27;static&#x27;:
      return [];
    case &#x27;optional&#x27;:
      return astNodeToNames(astNode.value);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.astNodeToRegexString" id="apidoc.element.url-pattern.astNodeToRegexString">
        function <span class="apidocSignatureSpan">url-pattern.</span>astNodeToRegexString
        <span class="apidocSignatureSpan">(astNode, segmentValueCharset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">astNodeToRegexString = function (astNode, segmentValueCharset) {
  if (segmentValueCharset == null) {
    segmentValueCharset = defaultOptions.segmentValueCharset;
  }
  return &#x27;^&#x27; + baseAstNodeToRegexString(astNode, segmentValueCharset) + &#x27;$&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.concatMap" id="apidoc.element.url-pattern.concatMap">
        function <span class="apidocSignatureSpan">url-pattern.</span>concatMap
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatMap = function (array, f) {
  var i, length, results;
  results = [];
  i = -1;
  length = array.length;
  while (++i &#x3c; length) {
    results = results.concat(f(array[i]));
  }
  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.escapeForRegex" id="apidoc.element.url-pattern.escapeForRegex">
        function <span class="apidocSignatureSpan">url-pattern.</span>escapeForRegex
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeForRegex = function (string) {
  return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, &#x27;\\$&#x26;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.getParam" id="apidoc.element.url-pattern.getParam">
        function <span class="apidocSignatureSpan">url-pattern.</span>getParam
        <span class="apidocSignatureSpan">(params, key, nextIndexes, sideEffects)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParam = function (params, key, nextIndexes, sideEffects) {
  var index, maxIndex, result, value;
  if (sideEffects == null) {
    sideEffects = false;
  }
  value = params[key];
  if (value == null) {
    if (sideEffects) {
      throw new Error(&#x22;no values provided for key `&#x22; + key + &#x22;`&#x22;);
    } else {
      return;
    }
  }
  index = nextIndexes[key] || 0;
  maxIndex = Array.isArray(value) ? value.length - 1 : 0;
  if (index &#x3e; maxIndex) {
    if (sideEffects) {
      throw new Error(&#x22;too few values provided for key `&#x22; + key + &#x22;`&#x22;);
    } else {
      return;
    }
  }
  result = Array.isArray(value) ? value[index] : value;
  if (sideEffects) {
    nextIndexes[key] = index + 1;
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.keysAndValuesToObject" id="apidoc.element.url-pattern.keysAndValuesToObject">
        function <span class="apidocSignatureSpan">url-pattern.</span>keysAndValuesToObject
        <span class="apidocSignatureSpan">(keys, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keysAndValuesToObject = function (keys, values) {
  var i, key, length, object, value;
  object = {};
  i = -1;
  length = keys.length;
  while (++i &#x3c; length) {
    key = keys[i];
    value = values[i];
    if (value == null) {
      continue;
    }
    if (object[key] != null) {
      if (!Array.isArray(object[key])) {
        object[key] = [object[key]];
      }
      object[key].push(value);
    } else {
      object[key] = value;
    }
  }
  return object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.newParser" id="apidoc.element.url-pattern.newParser">
        function <span class="apidocSignatureSpan">url-pattern.</span>newParser
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newParser = function (options) {
  var U;
  U = {};
  U.wildcard = P.tag(&#x27;wildcard&#x27;, P.string(options.wildcardChar));
  U.optional = P.tag(&#x27;optional&#x27;, P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {
    return U.pattern;
  }), P.string(options.optionalSegmentEndChar)));
  U.name = P.regex(new RegExp(&#x22;^[&#x22; + options.segmentNameCharset + &#x22;]+&#x22;));
  U.named = P.tag(&#x27;named&#x27;, P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {
    return U.name;
  })));
  U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));
  U[&#x22;static&#x22;] = P.tag(&#x27;static&#x27;, P.concatMany1Till(P.firstChoice(P.lazy(function() {
    return U.escapedChar;
  }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string
(options.optionalSegmentEndChar), U.wildcard)));
  U.token = P.lazy(function() {
    return P.firstChoice(U.wildcard, U.optional, U.named, U[&#x22;static&#x22;]);
  });
  U.pattern = P.many1(P.lazy(function() {
    return U.token;
  }));
  return U;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.regexGroupCount" id="apidoc.element.url-pattern.regexGroupCount">
        function <span class="apidocSignatureSpan">url-pattern.</span>regexGroupCount
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regexGroupCount = function (regex) {
  return (new RegExp(regex.toString() + &#x27;|&#x27;)).exec(&#x27;&#x27;).length - 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.stringConcatMap" id="apidoc.element.url-pattern.stringConcatMap">
        function <span class="apidocSignatureSpan">url-pattern.</span>stringConcatMap
        <span class="apidocSignatureSpan">(array, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringConcatMap = function (array, f) {
  var i, length, result;
  result = &#x27;&#x27;;
  i = -1;
  length = array.length;
  while (++i &#x3c; length) {
    result += f(array[i]);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.stringify" id="apidoc.element.url-pattern.stringify">
        function <span class="apidocSignatureSpan">url-pattern.</span>stringify
        <span class="apidocSignatureSpan">(astNode, params, nextIndexes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (astNode, params, nextIndexes) {
  if (Array.isArray(astNode)) {
    return stringConcatMap(astNode, function(node) {
      return stringify(node, params, nextIndexes);
    });
  }
  switch (astNode.tag) {
    case &#x27;wildcard&#x27;:
      return getParam(params, &#x27;_&#x27;, nextIndexes, true);
    case &#x27;named&#x27;:
      return getParam(params, astNode.value, nextIndexes, true);
    case &#x27;static&#x27;:
      return astNode.value;
    case &#x27;optional&#x27;:
      if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {
        return stringify(astNode.value, params, nextIndexes);
      } else {
        return &#x27;&#x27;;
      }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pattern.match(&#x27;/api/users/10&#x27;); // {id: &#x27;10&#x27;}
pattern.match(&#x27;/api/users&#x27;); // {}
pattern.match(&#x27;/api/products/5&#x27;); // null
```

[generate string from pattern and values:](#stringify-patterns)
``` javascript
pattern.<span class="apidocCodeKeywordSpan">stringify</span>() // &#x27;/api/users&#x27;
pattern.stringify({id: 20}) // &#x27;/api/users/20&#x27;
```

- continuously tested in Node.js (0.12, 4.2.3 and 5.3) and all relevant browsers:
  [![Sauce Test Status](https://saucelabs.com/browser-matrix/urlpattern.svg)](https://saucelabs.com/u/urlpattern)
- [tiny single file with just under 500 lines of simple, readable, maintainable code](src/url-pattern.coffee)
- [huge test suite](test)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url-pattern.P" id="apidoc.module.url-pattern.P">module url-pattern.P</a></h1>


    <h2>
        <a href="#apidoc.element.url-pattern.P.Result" id="apidoc.element.url-pattern.P.Result">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>Result
        <span class="apidocSignatureSpan">(value, rest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Result = function (value, rest) {
  this.value = value;
  this.rest = rest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.Tagged" id="apidoc.element.url-pattern.P.Tagged">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>Tagged
        <span class="apidocSignatureSpan">(tag, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tagged = function (tag, value) {
  this.tag = tag;
  this.value = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.baseMany" id="apidoc.element.url-pattern.P.baseMany">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>baseMany
        <span class="apidocSignatureSpan">(parser, end, stringResult, atLeastOneResultRequired, input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">baseMany = function (parser, end, stringResult, atLeastOneResultRequired, input) {
  var endResult, parserResult, rest, results;
  rest = input;
  results = stringResult ? &#x27;&#x27; : [];
  while (true) {
    if (end != null) {
      endResult = end(rest);
      if (endResult != null) {
        break;
      }
    }
    parserResult = parser(rest);
    if (parserResult == null) {
      break;
    }
    if (stringResult) {
      results += parserResult.value;
    } else {
      results.push(parserResult.value);
    }
    rest = parserResult.rest;
  }
  if (atLeastOneResultRequired &#x26;&#x26; results.length === 0) {
    return;
  }
  return new P.Result(results, rest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.concatMany1Till" id="apidoc.element.url-pattern.P.concatMany1Till">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>concatMany1Till
        <span class="apidocSignatureSpan">(parser, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatMany1Till = function (parser, end) {
  return function(input) {
    return P.baseMany(parser, end, true, true, input);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.firstChoice" id="apidoc.element.url-pattern.P.firstChoice">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>firstChoice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firstChoice = function () {
  var parsers;
  parsers = 1 &#x3c;= arguments.length ? slice.call(arguments, 0) : [];
  return function(input) {
    var i, length, parser, result;
    i = -1;
    length = parsers.length;
    while (++i &#x3c; length) {
      parser = parsers[i];
      result = parser(input);
      if (result != null) {
        return result;
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.lazy" id="apidoc.element.url-pattern.P.lazy">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>lazy
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lazy = function (fn) {
  var cached;
  cached = null;
  return function(input) {
    if (cached == null) {
      cached = fn();
    }
    return cached(input);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.many1" id="apidoc.element.url-pattern.P.many1">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>many1
        <span class="apidocSignatureSpan">(parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">many1 = function (parser) {
  return function(input) {
    return P.baseMany(parser, null, false, true, input);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.pick" id="apidoc.element.url-pattern.P.pick">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>pick
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pick = function () {
  var indexes, parsers;
  indexes = arguments[0], parsers = 2 &#x3c;= arguments.length ? slice.call(arguments, 1) : [];
  return function(input) {
    var array, result;
    result = P.sequence.apply(P, parsers)(input);
    if (result == null) {
      return;
    }
    array = result.value;
    result.value = array[indexes];
    return result;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.regex" id="apidoc.element.url-pattern.P.regex">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>regex
        <span class="apidocSignatureSpan">(regex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regex = function (regex) {
  return function(input) {
    var matches, result;
    matches = regex.exec(input);
    if (matches == null) {
      return;
    }
    result = matches[0];
    return new P.Result(result, input.slice(result.length));
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.sequence" id="apidoc.element.url-pattern.P.sequence">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>sequence
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequence = function () {
  var parsers;
  parsers = 1 &#x3c;= arguments.length ? slice.call(arguments, 0) : [];
  return function(input) {
    var i, length, parser, rest, result, values;
    i = -1;
    length = parsers.length;
    values = [];
    rest = input;
    while (++i &#x3c; length) {
      parser = parsers[i];
      result = parser(rest);
      if (result == null) {
        return;
      }
      values.push(result.value);
      rest = result.rest;
    }
    return new P.Result(values, rest);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.string" id="apidoc.element.url-pattern.P.string">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>string
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (string) {
  var length;
  length = string.length;
  return function(input) {
    if (input.slice(0, length) === string) {
      return new P.Result(string, input.slice(length));
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url-pattern.P.tag" id="apidoc.element.url-pattern.P.tag">
        function <span class="apidocSignatureSpan">url-pattern.P.</span>tag
        <span class="apidocSignatureSpan">(tag, parser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tag = function (tag, parser) {
  return function(input) {
    var result, tagged;
    result = parser(input);
    if (result == null) {
      return;
    }
    tagged = new P.Tagged(tag, result.value);
    return new P.Result(tagged, result.rest);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
